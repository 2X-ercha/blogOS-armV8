# 实验构建及运行

> 你将在每个实验对应分支上都看到这句话，确保作者实验代码在被下载后，能在正确的环境中运行。

运行环境请参考: [lab1 环境搭建](https://github.com/2X-ercha/blogOS-armV8/tree/lab1/docs/environment)

```bash
cargo build
qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/blogos_armv8
```

--------

# 实验二 Hello World

上一个实验里，我们已经初步实现了让内核运行一开始输出`"Hello World"`，也初步了解到程序是如何调用硬件设备的寄存器。然而我们希望能在实验的每一个rust代码文件中，都能方便的调用`print`，而不是每一次输出都需要写一大串代码。

用函数模块化固然是个不错的方法，但当我们想调用它时就需要向`c`语言那样调用`stdio.h`头文件。这时候我们就需要了解`rust`本身的一个高级特性：宏

所以实验二我们将实现`rust`中最经典的宏：`print!`和`println!`，以便于后续的调试输出。

注：至于实验指导书中关于`virt`机器和设备树的部分，我会将其放到选做的实验三。实验三选做但是必要，是理解后续实验的关键。另外吐槽的是这节的实验指导书意外的还不错，我可以偷懒一点。

--------

## 实验目的

实验二的开头是这么说的：

> 本实验的目的在于理解操作系统与硬件的接口方法，并实现一个可打印字符的宏（非系统调用），用于后续的调试和开发。

其实我们在`not_main`函数中就已经完成的对串口作了硬件上的调用，而更具体的调用则需要阅读设备树源文件和设备寄存器接口文档。这将在实验三实验四会有更实际的体现。所以实验目的我认为是如下几点（第一点其实也不太重要）：

1. 初步了解rust宏（rust语言特性，可略过）

2. 将实验一的输出封装成实例以便调用

3. 将实例封装成宏，实现`print!`和`println!`

--------

## 目录

* [rust 宏（选看）（目的1）](./docs/macro/)

* [Write 实例实现和测试（目的2）](./docs/write/)

* [print!和println!封装（目的3）](./docs/print!/)
