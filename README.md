# 实验构建及运行

> 你将在每个实验对应分支上都看到这句话，确保作者实验代码在被下载后，能在正确的环境中运行。

运行环境请参考: [lab1 环境搭建](https://github.com/2X-ercha/blogOS-armV8/tree/lab1/docs/environment)

```bash
cargo build
qemu-system-aarch64 -machine virt -m 1024M -cpu cortex-a53 -nographic -kernel target/aarch64-unknown-none-softfloat/debug/blogos_armv8 -semihosting
```

--------

# 实验七 死锁与简单处理

现在内核中存在一种并发的情形：定时器中断是异步发生的，因此它们可以随时中断我们的 `not_main` 函数。 幸运的是，Rust 的所有权系统可以在编译时防止许多种类型的与并发相关的错误。 但死锁是一个值得注意的例外。 如果一个线程试图获取一个永远不会释放的锁，就会发生死锁。 这样，线程将会无限期地处于挂起状态。

当多个任务访问同一个资源（数据）是就会引发竞争条件问题，这不仅在进程间会出现，在操作系统和进程间也会出现，此时就可能会产生死锁。另外的是多进程的死锁会显得更加有趣，我们的系统只有单进程系统，故在此不考虑。

--------

## 实验目的

了解竞争条件和死锁现象，并掌握处理这些问题的初步方法等。虽然在于一个没有调度的系统上讲有点奇怪，不过作为实验性课程也足够了

1. 死锁如何发生，如何在我们的内核中引发死锁

2. 针对情况解决我们程序的死锁，以及了解更科学的死锁解决方式

--------

## 目录

这部分太短了就懒得写多节了。。。

* [内核死锁发生原理、引发死锁及解决方法](./docs/)
