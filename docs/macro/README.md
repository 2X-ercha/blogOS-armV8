## rust 宏（选看）

### 什么是宏？

熟悉C/C++的应该很熟悉宏（`Macro`）的概念，而Rust初学者也必定会接触到Rust中的宏。

可以简单地理解为：宏即编译时将执行的一系列指令。其重点在于「编译时」，尽管宏与函数（或方法）形似，函数是在运行时发生调用的，而宏是在编译时执行的。

不同于C/C++中的宏，Rust的宏并非简单的文本替换，而是在词法层面甚至语法树层面作替换，其功能更加强大，也更加安全。

如下所示的一个C++的宏SQR的定义

```c
#include <iostream>
#define SQR(x) (x * x)
int main() {
    std::cout << SQR(1 + 1) << std::endl;
    return 0;
} 
```

我们希望它输出4，但很遗憾它将输出3，因为`SQR(1 + 1)`在预编译阶段通过文本替换展开将得到`(1 + 1 * 1 + 1)`（替换时没给你加括号），并非我们所期望的语义。

而在Rust中，按如下方式定义的宏：

```rust
macro_rules! sqr {
    ($x:expr) => {$x * $x}
}

fn main() {
    println!("{}", sqr!(1 + 1));
}
```

将得到正确的答案4。这是因为Rust的宏展开发生在语法分析阶段，此时编译器知道sqr!宏中的$x变量是一个表达式（用$x:expr标记），所以在展开后它知道如何正确处理，会将其展开为`((1 + 1) * (1 + 1))`。

--------

### 宏和函数的区别

从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的**元编程（metaprogramming）**。所有的这些宏以**展开**的方式来生成比你所手写出的更多的代码。

元编程对于减少大量编写和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有一些函数所没有的附加能力。

一个函数标签必须声明函数参数个数和类型。相比之下，宏能够接受不同数量的参数：用一个参数调用`println!("hello")`或用两个参数调用`println!("hello {}", name)`。而且，宏可以在编译器翻译代码前展开，例如，宏可以在一个给定类型上实现`trait`。而函数则不行，因为函数是在运行时被调用，同时`trait`需要在编译时实现。

实现一个宏而不是一个函数的缺点是宏定义要比函数定义更复杂，因为你正在编写**生成 Rust 代码的 Rust 代码**。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护。

宏和函数的最后一个重要的区别是：在一个文件里调用宏之前必须定义它，或将其引入作用域，而函数则可以在任何地方定义和调用。

--------

### 宏的分类

宏可以分为：使用 macro_rules! 的 声明（Declarative）宏，和三种 过程（Procedural）宏：

* 自定义 #[derive] 宏在结构体和枚举上指定通过 derive 属性添加的代码

* 类属性（Attribute-like）宏定义可用于任意项的自定义属性

* 类函数宏看起来像函数不过作用于作为参数传递的 token

这里我们只了解声明宏。我们的`print!`和`println!`宏都是声明宏。

--------

### 声明宏

Rust 最常用的宏形式是 声明宏（declarative macros）。它们有时也被称为 “macros by example”、“macro_rules! 宏” 或者就是 “macros”。其核心概念是，声明宏允许我们编写一些类似 Rust match 表达式的代码。match 表达式是控制结构，其接收一个表达式，与表达式的结果进行模式匹配，然后根据模式匹配执行相关代码。宏也将一个值和包含相关代码的模式进行比较；此种情况下，该值是传递给宏的 Rust 源代码字面值，模式用于和传递给宏的源代码进行比较，同时每个模式的相关代码则用于替换传递给宏的代码。所有这一切都发生于编译时。

可以使用 macro_rules! 来定义宏，如：

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

无论何时导入定义了宏的包，`#[macro_export]`注解说明宏应该是可用的。 如果没有该注解，这个宏不能被引入作用域。

接着使用 `macro_rules!` 和宏名称开始宏定义，且所定义的宏并不带感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 `vec` 。

首先，一对括号包含了整个模式。接下来是美元符号（`$`），后跟一对括号，捕获了符合括号内模式的值以用于替换后的代码。`$()`内则是`$x:expr`，其匹配Rust的任意表达式，并将该表达式记作`$x`。

`$()`之后的逗号说明一个可有可无的逗号分隔符可以出现在`$()`所匹配的代码之后。紧随逗号之后的`*`说明该模式匹配零个或更多个`*`之前的任何模式。

当以`vec![1, 2, 3];`调用宏时，`$x`模式与三个表达式 1、2 和 3 进行了三次匹配。